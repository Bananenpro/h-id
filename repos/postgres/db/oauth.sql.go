// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: oauth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgconn"
)

const createOAuthToken = `-- name: CreateOAuthToken :one
INSERT INTO oauth (
  created_at, category, token_hash, redirect_uri, client_id, user_id, scopes, data, expires, used
) VALUES (
  $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
) RETURNING created_at, client_id, category, token_hash, redirect_uri, user_id, scopes, data, expires, used
`

type CreateOAuthTokenParams struct {
	CreatedAt   int64
	Category    string
	TokenHash   []byte
	RedirectUri string
	ClientID    string
	UserID      string
	Scopes      string
	Data        []byte
	Expires     int64
	Used        bool
}

func (q *Queries) CreateOAuthToken(ctx context.Context, arg CreateOAuthTokenParams) (Oauth, error) {
	row := q.db.QueryRow(ctx, createOAuthToken,
		arg.CreatedAt,
		arg.Category,
		arg.TokenHash,
		arg.RedirectUri,
		arg.ClientID,
		arg.UserID,
		arg.Scopes,
		arg.Data,
		arg.Expires,
		arg.Used,
	)
	var i Oauth
	err := row.Scan(
		&i.CreatedAt,
		&i.ClientID,
		&i.Category,
		&i.TokenHash,
		&i.RedirectUri,
		&i.UserID,
		&i.Scopes,
		&i.Data,
		&i.Expires,
		&i.Used,
	)
	return i, err
}

const deleteOAuthToken = `-- name: DeleteOAuthToken :execresult
DELETE FROM oauth WHERE (client_id = $1 AND category = $2 AND token_hash = $3) OR expires < $4
`

type DeleteOAuthTokenParams struct {
	ClientID  string
	Category  string
	TokenHash []byte
	Now       int64
}

func (q *Queries) DeleteOAuthToken(ctx context.Context, arg DeleteOAuthTokenParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, deleteOAuthToken,
		arg.ClientID,
		arg.Category,
		arg.TokenHash,
		arg.Now,
	)
}

const deleteOAuthTokenByUser = `-- name: DeleteOAuthTokenByUser :exec
DELETE FROM oauth WHERE (client_id = $1 AND user_id = $2) OR expires < $3
`

type DeleteOAuthTokenByUserParams struct {
	ClientID string
	UserID   string
	Now      int64
}

func (q *Queries) DeleteOAuthTokenByUser(ctx context.Context, arg DeleteOAuthTokenByUserParams) error {
	_, err := q.db.Exec(ctx, deleteOAuthTokenByUser, arg.ClientID, arg.UserID, arg.Now)
	return err
}

const findOAuthPermissions = `-- name: FindOAuthPermissions :one
SELECT created_at, client_id, user_id, scopes FROM permissions WHERE client_id = $1 AND user_id = $2
`

type FindOAuthPermissionsParams struct {
	ClientID string
	UserID   string
}

func (q *Queries) FindOAuthPermissions(ctx context.Context, arg FindOAuthPermissionsParams) (Permission, error) {
	row := q.db.QueryRow(ctx, findOAuthPermissions, arg.ClientID, arg.UserID)
	var i Permission
	err := row.Scan(
		&i.CreatedAt,
		&i.ClientID,
		&i.UserID,
		&i.Scopes,
	)
	return i, err
}

const findOAuthToken = `-- name: FindOAuthToken :one
SELECT created_at, client_id, category, token_hash, redirect_uri, user_id, scopes, data, expires, used FROM oauth WHERE category = $1 AND token_hash = $2 AND expires > $3
`

type FindOAuthTokenParams struct {
	Category  string
	TokenHash []byte
	Now       int64
}

func (q *Queries) FindOAuthToken(ctx context.Context, arg FindOAuthTokenParams) (Oauth, error) {
	row := q.db.QueryRow(ctx, findOAuthToken, arg.Category, arg.TokenHash, arg.Now)
	var i Oauth
	err := row.Scan(
		&i.CreatedAt,
		&i.ClientID,
		&i.Category,
		&i.TokenHash,
		&i.RedirectUri,
		&i.UserID,
		&i.Scopes,
		&i.Data,
		&i.Expires,
		&i.Used,
	)
	return i, err
}

const revokeOAuthPermissions = `-- name: RevokeOAuthPermissions :execresult
DELETE FROM permissions WHERE client_id = $1 AND user_id = $2
`

type RevokeOAuthPermissionsParams struct {
	ClientID string
	UserID   string
}

func (q *Queries) RevokeOAuthPermissions(ctx context.Context, arg RevokeOAuthPermissionsParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, revokeOAuthPermissions, arg.ClientID, arg.UserID)
}

const setOAuthPermissions = `-- name: SetOAuthPermissions :one
INSERT INTO permissions (
  created_at,client_id,user_id,scopes
) VALUES ($1,$2,$3,$4)
ON CONFLICT(client_id,user_id) DO UPDATE SET created_at = $1, client_id = $2, user_id = $3, scopes = $4
RETURNING created_at, client_id, user_id, scopes
`

type SetOAuthPermissionsParams struct {
	CreatedAt int64
	ClientID  string
	UserID    string
	Scopes    string
}

func (q *Queries) SetOAuthPermissions(ctx context.Context, arg SetOAuthPermissionsParams) (Permission, error) {
	row := q.db.QueryRow(ctx, setOAuthPermissions,
		arg.CreatedAt,
		arg.ClientID,
		arg.UserID,
		arg.Scopes,
	)
	var i Permission
	err := row.Scan(
		&i.CreatedAt,
		&i.ClientID,
		&i.UserID,
		&i.Scopes,
	)
	return i, err
}

const useOAuthToken = `-- name: UseOAuthToken :execresult
UPDATE oauth SET used = TRUE WHERE client_id = $1 AND category = $2 AND token_hash = $3
`

type UseOAuthTokenParams struct {
	ClientID  string
	Category  string
	TokenHash []byte
}

func (q *Queries) UseOAuthToken(ctx context.Context, arg UseOAuthTokenParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, useOAuthToken, arg.ClientID, arg.Category, arg.TokenHash)
}
